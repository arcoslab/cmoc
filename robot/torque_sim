#!/usr/bin/env python
# Copyright (c) 2010 Technische Universitaet Muenchen, Informatik Lehrstuhl IX.
# Author: Federico Ruiz-Ugalde
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#This module connects to the arm joint ports and to the hand to calculate its jacobians to calculate expected torques in the torque sensors given external forces in each finger tip.

import sys, os
import yarp
import time
from cmoc.robot.sim_handlers import Joint_sim, Finger_sim, Hand_sim, Sim_torques
sys.path.append("../../temp/pyrovito/")
from pyrovito.pyrovito_utils import Roboviewer_objects
from time import sleep
import numpy
import optparse
from arcospyu.numeric import quat
from numpy import array
        

class Force_input():
    def __init__(self,baseportname):
        self.force_input_port=yarp.BufferedPortBottle()
        self.force_input_port.open(baseportname+"/force_in")
        self.forces=[array([0.]*3)]*10

    def get_force(self):
        force_input_bottle=self.force_input_port.read(False)
        if force_input_bottle:
            return(map(yarp.Value.asDouble,map(force_input_bottle.get,xrange(3))))

    def get_forces(self):
        force_input_bottle=self.force_input_port.read(False)
        if force_input_bottle:
            bottle_list=map(yarp.Value.asList,
                            map(force_input_bottle.get,xrange(force_input_bottle.size())))
            for bottle in bottle_list:
                finger_id=bottle.get(0).asInt()
                self.forces[finger_id]=array(map(yarp.Value.asDouble,
                                                 map(bottle.get,xrange(1,bottle.size()))))
        return(self.forces)



class Force_out():
    def __init__(self,baseportname):
        self.force_out_port=yarp.BufferedPortBottle()
        self.force_out_port.open(baseportname+"/force_out")
    
    def send_data(self,forces,poses):
        bottle=self.force_out_port.prepare()
        bottle.clear()
        for force,pose in zip(forces,poses):
            rot=quat.from_matrix(pose)
            trans=pose[:3,3]
            bottle_list=bottle.addList()
            bottle_list.clear()
            for i in trans:
                bottle_list.addDouble(i)
            for i in rot:
                bottle_list.addDouble(i)
            for i in force:
                bottle_list.addDouble(i)
        self.force_out_port.write()

def main():
    simulation_on=False
    parser=optparse.OptionParser("usage: %prog [options]")
    parser.add_option("-s", "--simulation", action="store_true", dest="sim", default=False,help="Simulation")
    parser.add_option("-a", "--config_dir_arms", dest="config_dir_arms", default="robot_description/arcosbot/kinematics/lwr", type="string", help="Arms config directory")
    parser.add_option("-c", "--finger_cal_data", dest="finger_cal_data_filename", default="robot_description/arcosbot/kinematics/sahand/calibration_data/finger_calibration_data.py", type="string", help="Finger calibration data filename")
    parser.add_option("-f", "--config_hands", dest="config_hands", default="robot_description/arcosbot/kinematics/sahand/hands_kin.py", type="string", help="hands config filename")
    parser.add_option("-r", "--no-left", dest="no_left", action="store_true", default=False, help="Disable left arm")
    (options, args)= parser.parse_args(sys.argv[1:])

    from arcospyu.config_parser.config_parser import import_config
    fcd=import_config(options.finger_cal_data_filename)
    config_hands=import_config(options.config_hands)
    
    simulation_on=options.sim
    config_lwr_right=options.config_dir_arms+"/config-lwr-right.py"
    if not options.no_left:
        config_lwr_left=options.config_dir_arms+"/config-lwr-left.py"

    if options.no_left:
        sim_torques=Sim_torques(config_lwr_right, None, config_hands)
        finger_cant = 5
    else:
        sim_torques=Sim_torques(config_lwr_right, config_lwr_left, config_hands)
        finger_cant = 10
        
    if simulation_on:
        joint_sim_client_right=Joint_sim("/torque_sim/right","/lwr/right/joint_sim")
        rhand_sim_client=Hand_sim("right",0)
        if not options.no_left:
            joint_sim_client_left=Joint_sim("/torque_sim/left","/lwr/left/joint_sim")
            lhand_sim_client=Hand_sim("left",1)
        force_input=Force_input("/torque_sim")
    else:
        pass
    if True:
        print "Setting calibration offsets and factors"
        for finger,(angle_offset,torque_factor) in enumerate(zip(fcd.angle_calibration_data_right,fcd.torque_calibration_factors_right)):
            sim_torques.rhand.fingers[finger].angle_offsets=angle_offset
            sim_torques.rhand.fingers[finger].torque_calibration_factors=torque_factor
            print "Torque factor", sim_torques.rhand.fingers[finger].torque_calibration_factors
            sim_torques.rhand.update_angle_offsets(list_fingers=[finger])
        if not options.no_left:
            for finger,(angle_offset,torque_factor) in enumerate(zip(fcd.angle_calibration_data_left,fcd.torque_calibration_factors_left)):
                sim_torques.lhand.fingers[finger].angle_offsets=angle_offset
                sim_torques.lhand.fingers[finger].torque_calibration_factors=torque_factor
                sim_torques.lhand.update_angle_offsets(list_fingers=[finger])

    view_objects=Roboviewer_objects("/view_test","/lwr/roboviewer", counter=1000)
    force_out=Force_out("/torque_sim")

    #arm frames
    rarm_id=view_objects.create_object("frame")
    view_objects.send_prop(rarm_id,"scale",[0.07, 0.07,0.07])
    if not options.no_left:
        larm_id=view_objects.create_object("frame")
        view_objects.send_prop(larm_id,"scale",[0.07, 0.07,0.07])
    #finger frames
    finger_frame_ids=[view_objects.create_object("frame") for i in xrange(finger_cant)]
    view_objects.send_prop_multi(finger_frame_ids,["scale"]*finger_cant, [[0.03]*3]*finger_cant)

    #finger arrows (forces)
    finger_arrow_ids=[view_objects.create_object("arrow") for i in xrange(finger_cant)]
    view_objects.send_prop_multi(finger_arrow_ids,["scale"]*finger_cant, [[0.07]*3]*finger_cant)
    view_objects.send_prop_multi(finger_arrow_ids,["color"]*finger_cant, [[1.0,1.0,0.]]*finger_cant)


    force=[0.,0.,0.]


    counter=0
    while True:
        time.sleep(0.002)
        init_time=time.time()
        sim_torques.update_data()
        #updating viewer objects
        if counter==15:
            view_objects.send_prop(rarm_id,"pose", sim_torques.rarm_frame.reshape(16).tolist())
            if options.no_left:
                view_objects.send_prop_multi(finger_frame_ids,["pose"]*finger_cant,
                                             [numpy.reshape(i,(16)).tolist() for i in sim_torques.finger_tip_right])
                view_objects.send_prop_multi(finger_arrow_ids,["trans"]*finger_cant,
                                             [i[:,3][:3].tolist() for i in sim_torques.finger_tip_right])
            else:
                view_objects.send_prop(larm_id,"pose", sim_torques.larm_frame.reshape(16).tolist())
                view_objects.send_prop_multi(finger_frame_ids,["pose"]*finger_cant,
                                             [numpy.reshape(i,(16)).tolist() for i in sim_torques.finger_tip_right+sim_torques.finger_tip_left])
                view_objects.send_prop_multi(finger_arrow_ids,["trans"]*finger_cant,
                                             [i[:,3][:3].tolist() for i in sim_torques.finger_tip_right+sim_torques.finger_tip_left])
        if simulation_on:
            forces=force_input.get_forces()
            sim_torques.sim_forces_right=forces[:finger_cant]
            if not options.no_left:
                sim_torques.sim_forces_left=forces[finger_cant:]

        rarm_torques,rhand_torques=sim_torques.get_torques_all(arm=0)
        if not options.no_left:
            larm_torques,lhand_torques=sim_torques.get_torques_all(arm=1)
        if simulation_on:
            joint_sim_client_right.set_torques(0.1*rarm_torques)
            rhand_sim_client.set_torques_np(rhand_torques)
            if not options.no_left:
                joint_sim_client_left.set_torques(0.1*larm_torques)
                lhand_sim_client.set_torques_np(lhand_torques)

        #print "Estimated forces", sim_torques.get_forces()
        sim_torques.get_forces()

        if counter==15:
            counter=0
            if options.no_left:
                view_objects.send_prop_multi(finger_arrow_ids,["axis"]*finger_cant, [i*0.1 for  i in sim_torques.est_forces_right])
            else:
                view_objects.send_prop_multi(finger_arrow_ids,["axis"]*finger_cant, [i*0.1 for  i in sim_torques.est_forces_right+sim_torques.est_forces_left])

        counter+=1
        if options.no_left:
            force_out.send_data(sim_torques.est_forces_right,sim_torques.finger_tip_right)
        else:
            force_out.send_data(sim_torques.est_forces_right+sim_torques.est_forces_left,sim_torques.finger_tip_right+sim_torques.finger_tip_left)
        

if __name__=="__main__":
    main()
